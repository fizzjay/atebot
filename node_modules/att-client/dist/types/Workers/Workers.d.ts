type Callback = (...args: any) => Promise<any>;
type Task<T extends Callback> = () => ReturnType<T>;
type TaskCallback<T extends Callback> = (taskResult: void | TaskReturnValue<T>) => void;
type TaskResult<T extends Callback> = {
    worker: Worker<T>;
    result: IteratorResult<TaskReturnValue<T>, void>;
};
type TaskReturnValue<T extends Callback> = void | Awaited<ReturnType<T>>;
type Worker<T extends Callback> = AsyncGenerator<TaskReturnValue<T>, void, ReturnType<T>>;
export declare class Workers<T extends Callback> {
    maxConcurrency: number;
    pool: Map<Worker<T>, Promise<TaskResult<T>>>;
    tasks: IterableIterator<Task<T>>;
    workers: Worker<T>[];
    constructor(maxConcurrency: number);
    do(tasks: Task<T>[], callback?: TaskCallback<T>): Promise<TaskReturnValue<T>[]>;
    private createWorker;
    private assign;
    private watch;
}
export {};
