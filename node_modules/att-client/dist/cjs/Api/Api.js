"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Api = void 0;
require("./Endpoint.js");
class Api {
    client;
    headers;
    constructor(client) {
        this.client = client;
    }
    async auth() {
        if (typeof this.client.accessToken === 'undefined') {
            this.client.logger.error(`[API] Can't authorise API requests without an access token. Ordering client to refresh tokens.`);
            await this.client.refreshTokens();
            return;
        }
        this.headers = new Headers({
            'Content-Type': 'application/json',
            'x-api-key': this.client.config.xApiKey,
            'User-Agent': this.client.name,
            'Authorization': `Bearer ${this.client.accessToken}`
        });
    }
    async acceptGroupInvite(groupId) {
        const response = await this.request('POST', "/groups/invites/{groupId}", { groupId });
        return await response.json();
    }
    async getGroupInfo(groupId) {
        const response = await this.request('GET', "/groups/{groupId}", { groupId });
        return await response.json();
    }
    async getGroupMember(groupId, userId) {
        const response = await this.request('GET', "/groups/{groupId}/members/{userId}", { groupId, userId });
        return await response.json();
    }
    async getJoinedGroups() {
        const joinedGroups = [];
        let response;
        let paginationToken = null;
        do {
            response = await this.request('GET', "/groups/joined", undefined, {
                limit: 1000,
                ...(paginationToken === null ? {} : { paginationToken })
            });
            paginationToken = response.headers.get('paginationToken');
            joinedGroups.push(...(await response.json()));
        } while (paginationToken !== null);
        return joinedGroups;
    }
    async getPendingGroupInvites() {
        const pendingInvites = [];
        let response;
        let paginationToken = null;
        do {
            response = await this.request('GET', "/groups/invites", undefined, {
                limit: 1000,
                ...(paginationToken === null ? {} : { paginationToken })
            });
            paginationToken = response.headers.get('paginationToken');
            pendingInvites.push(...(await response.json()));
        } while (paginationToken !== null);
        return pendingInvites;
    }
    async getServerConnectionDetails(serverId) {
        const response = await this.request('POST', "/servers/{serverId}/console", { serverId }, undefined, {
            should_launch: false,
            ignore_offline: false
        });
        return await response.json();
    }
    async getServerInfo(serverId) {
        const response = await this.request('GET', "/servers/{serverId}", { serverId });
        return await response.json();
    }
    async request(method, endpoint, params, query, payload, attemptsLeft = this.client.config.apiRequestAttempts) {
        if (typeof this.headers === 'undefined') {
            this.client.logger.error(`[API] Not authorised. Ordering authorisation now.`);
            await this.auth();
            return await this.request(method, endpoint, params, query, payload);
        }
        const url = this.createUrl(endpoint, params, query);
        this.client.logger.debug(`[API] ${method} ${url}`, JSON.stringify(payload));
        let response;
        try {
            response = await Promise.race([
                fetch(url.toString(), {
                    method,
                    headers: this.headers,
                    body: typeof payload === 'undefined' ? null : JSON.stringify(payload)
                }),
                new Promise((_, reject) => setTimeout(() => {
                    reject(new Error(`${method} ${url} request timed out.`));
                }, this.client.config.apiRequestTimeout))
            ]);
            if (!response.ok) {
                this.client.logger.error(`[API] ${method} ${response.url} responded with ${response.status} ${response.statusText}.`);
                const body = await response.json();
                throw new Error('message' in body ? body.message : JSON.stringify(body));
            }
        }
        catch (error) {
            this.client.logger.error(`[API] ${method} ${url} error: ${error.message}`);
            if (attemptsLeft > 0) {
                this.client.logger.debug(`[API] ${method} ${url} retrying in ${this.client.config.apiRequestRetryDelay} ms.`);
                await new Promise(resolve => setTimeout(resolve, this.client.config.apiRequestRetryDelay));
                return await this.request(method, endpoint, params, query, payload, attemptsLeft - 1);
            }
            else {
                throw new Error(`[API] ${method} ${url} exhausted request attempts.`);
            }
        }
        return response;
    }
    createUrl(template, params = {}, query) {
        const endpoint = template.replace(/{(.*?)}/g, (_, match) => params[match]?.toString() ?? `{${match}}`);
        const url = new URL(`${this.client.config.restBaseUrl}${endpoint}`);
        if (typeof query !== 'undefined') {
            Object.entries(query).forEach(([key, value]) => url.searchParams.append(key, value.toString()));
        }
        return url;
    }
}
exports.Api = Api;
