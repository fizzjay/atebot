"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerConnection = void 0;
const node_events_1 = __importDefault(require("node:events"));
const tiny_typed_emitter_1 = require("@mdingena/tiny-typed-emitter");
const ws_1 = require("ws");
class ServerConnection extends tiny_typed_emitter_1.TypedEmitter {
    server;
    commandId;
    events;
    subscribedEvents;
    ws;
    constructor(server, address, port, token) {
        super();
        this.commandId = 1;
        this.events = new node_events_1.default();
        this.server = server;
        this.subscribedEvents = [];
        const that = this;
        function handleError(error) {
            that.server.group.client.logger.error(`[CONSOLE-${that.server.id}] An error occurred.`, error.message);
            that.emit('error', error);
        }
        function handlePing(data) {
            that.server.group.client.logger.debug(`[CONSOLE-${that.server.id}] Received ping.`, data.toString());
            this.pong(data);
        }
        function handlePong(data) {
            that.server.group.client.logger.debug(`[CONSOLE-${that.server.id}] Received pong.`, data.toString());
        }
        function handleClose(code, reason) {
            that.server.group.client.logger.debug(`[CONSOLE-${that.server.id}] Closing with code ${code}: ${reason.toString()}.`);
            this.removeAllListeners();
            that.emit('close', code, reason);
        }
        function handleMessage(data, isBinary) {
            if (isBinary) {
                that.server.group.client.logger.error(`[CONSOLE-${that.server.id}] Puking horses! ðŸ´ðŸ´ðŸ¤®`);
                that.server.group.client.logger.debug(`[CONSOLE-${that.server.id}] Received binary data:`, data.toString());
                return;
            }
            const message = JSON.parse(data.toString());
            const eventName = typeof message.commandId === 'undefined'
                ? `${message.type}${typeof message.eventType === 'undefined' ? '' : `/${message.eventType}`}`
                : `command-${message.commandId}`;
            that.server.group.client.logger.debug(`[CONSOLE-${that.server.id}] Received ${eventName} message.`, JSON.stringify(message));
            if (that.server.status === 'connecting' &&
                message.type === 'SystemMessage' &&
                message.eventType === 'InfoLog' &&
                message.data.startsWith('Connection Succeeded')) {
                that.emit('open');
                return;
            }
            that.events.emit(eventName, message);
        }
        function handleOpen() {
            that.server.group.client.logger.debug(`[CONSOLE-${that.server.id}] Opened.`);
            this.on('ping', handlePing);
            this.on('pong', handlePong);
            this.on('message', handleMessage);
            this.send(token, error => {
                if (error) {
                    that.server.group.client.logger.error(`[CONSOLE-${that.server.id}] Couldn't authenticate console connection.`, error.message);
                    return;
                }
                that.server.group.client.logger.debug(`[CONSOLE-${that.server.id}] Authenticated console connection.`);
            });
        }
        this.ws = new ws_1.WebSocket(`ws://${address}:${port}`);
        this.ws.on('error', handleError);
        this.ws.once('close', handleClose);
        this.ws.once('open', handleOpen);
    }
    getCommandId() {
        return this.commandId++;
    }
    send(command) {
        if (/^(websocket )?(un)?subscribe/i.test(command)) {
            throw new Error(`Do not use send() to (un)subscribe to events. Please use subscribe() or unsubscribe() instead.`);
        }
        return this.command(command);
    }
    command(command) {
        return new Promise((resolve, reject) => {
            const id = this.getCommandId();
            this.events.once(`command-${id}`, (message) => resolve(message));
            const message = JSON.stringify({ id, content: command });
            this.server.group.client.logger.debug(`[CONSOLE-${this.server.id}] Sending command-${id}.`, message);
            this.ws.send(message, error => error && reject(error));
        });
    }
    subscribe(event, callback) {
        if (this.subscribedEvents.includes(event)) {
            throw new Error(`[CONSOLE-${this.server.id}] Already subscribed to ${event}.`);
        }
        this.server.group.client.logger.info(`[CONSOLE-${this.server.id}] Subscribing to ${event}.`);
        this.subscribedEvents = [...this.subscribedEvents, event];
        this.events.on(`Subscription/${event}`, callback);
        return this.command(`websocket subscribe ${event}`);
    }
    unsubscribe(event) {
        if (!this.subscribedEvents.includes(event)) {
            throw new Error(`[CONSOLE-${this.server.id}] Subscription to ${event} does not exist.`);
        }
        this.server.group.client.logger.info(`[CONSOLE-${this.server.id}] Unsubscribing to ${event}.`);
        this.subscribedEvents = this.subscribedEvents.filter(existing => existing !== event);
        this.events.removeAllListeners(`Subscription/${event}`);
        return this.command(`websocket unsubscribe ${event}`);
    }
    dispose() {
        this.ws.close(1000, 'Disposing console connection.');
        this.events.removeAllListeners();
    }
    disconnect() {
        this.server.disconnect();
    }
}
exports.ServerConnection = ServerConnection;
