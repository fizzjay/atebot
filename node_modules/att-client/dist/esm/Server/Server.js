import { TypedEmitter } from '@mdingena/tiny-typed-emitter';
import { ServerConnection } from '../ServerConnection/index.js';
export class Server extends TypedEmitter {
    description;
    group;
    id;
    name;
    playability;
    players;
    status;
    fleet;
    connection;
    keepAlive;
    missedHeartbeats;
    constructor(group, server) {
        super();
        this.description = server.description ?? '';
        this.fleet = server.fleet;
        this.group = group;
        this.id = server.id;
        this.keepAlive = undefined;
        this.missedHeartbeats = 0;
        this.name = server.name ?? group.name ?? '';
        this.playability = server.playability;
        this.players = server.online_players;
        this.status = 'disconnected';
        this.emit('update', this);
    }
    async connect() {
        if (typeof this.connection !== 'undefined') {
            throw new Error(`[SERVER-${this.id}] Can't open a second console connection.`);
        }
        this.status = 'connecting';
        const serverConnectionInfo = await this.group.client.api.getServerConnectionDetails(this.id);
        if ('ok' in serverConnectionInfo) {
            this.status = 'disconnected';
            throw new Error(`[SERVER-${this.id}] Couldn't get connection details.`);
        }
        return await new Promise((resolve, reject) => {
            this.group.client.logger.debug(`[SERVER-${this.id}] Got connection details.`, JSON.stringify(serverConnectionInfo));
            const { allowed, connection: connectionDetails, token } = serverConnectionInfo;
            if (typeof connectionDetails === 'undefined') {
                this.status = 'disconnected';
                return reject(new Error(`[SERVER-${this.id}] Console WebSocket details are missing. ${serverConnectionInfo.message}`));
            }
            if (typeof token === 'undefined') {
                this.status = 'disconnected';
                return reject(new Error(`[SERVER-${this.id}] Console WebSocket token is missing.`));
            }
            if (!allowed) {
                this.status = 'disconnected';
                return reject(new Error(`[SERVER-${this.id}] Client is not allowed to use this server's console. Check that the bot account for this client was granted "Console" permissions.`));
            }
            const { address, websocket_port: port } = connectionDetails;
            const that = this;
            function handleError(error) {
                that.group.client.logger.error(`[SERVER-${that.id}] Error on console connection.`, error.message);
                if (that.status !== 'connected') {
                    reject(error);
                }
            }
            function handleOpen() {
                that.group.client.logger.info(`[SERVER-${that.id}] Console connection opened. (${that.name})`);
                that.status = 'connected';
                that.emit('connect', this);
                that.group.client.emit('connect', this);
                resolve(this);
            }
            async function handleClose(code, reason) {
                if (code === 1000) {
                    that.disconnect();
                }
                else {
                    that.group.client.logger.info(`[SERVER-${that.id}] Console connection closed. (${that.name})`, code, reason?.toString());
                    await that.reconnect();
                }
            }
            const connection = new ServerConnection(this, address, port, token);
            connection.on('error', handleError.bind(connection));
            connection.once('close', handleClose.bind(connection));
            connection.once('open', handleOpen.bind(connection));
            this.connection = connection;
        });
    }
    disconnect() {
        clearInterval(this.keepAlive);
        if (typeof this.connection === 'undefined')
            return;
        this.group.client.logger.info(`[SERVER-${this.id}] Closing console connection.`);
        this.connection.dispose();
        delete this.connection;
        this.status = 'disconnected';
    }
    async reconnect() {
        if (typeof this.connection === 'undefined')
            return;
        this.disconnect();
        this.group.client.logger.info(`[SERVER-${this.id}] Reopening console connection in ${this.group.client.config.serverConnectionRecoveryDelay} ms.`);
        await new Promise(resolve => setTimeout(resolve, this.group.client.config.serverConnectionRecoveryDelay));
        try {
            await this.connect();
        }
        catch (error) {
            this.group.client.logger.error(error.message);
            await this.reconnect();
        }
    }
    update(status) {
        this.description = status.description;
        this.name = status.name;
        this.playability = status.playability;
        this.players = status.online_players;
        this.fleet = status.fleet;
        this.emit('update', this);
    }
    handleHeartbeat(status) {
        clearInterval(this.keepAlive);
        this.missedHeartbeats = 0;
        if (status.is_online) {
            this.keepAlive = setInterval(() => {
                this.group.client.logger.info(`[SERVER-${this.id}] No heartbeat received in the last ${this.group.client.config.serverHeartbeatInterval * ++this.missedHeartbeats} ms.`);
                if (this.missedHeartbeats >= this.group.client.config.maxMissedServerHeartbeats) {
                    this.group.client.logger.info(`[SERVER-${this.id}] Maximum missed heartbeats reached. Closing connection.`);
                    this.disconnect();
                }
            }, this.group.client.config.serverHeartbeatInterval);
        }
    }
    dispose() {
        this.disconnect();
    }
}
