import { EventEmitter } from 'node:events';
import { WebSocket } from 'ws';
import '../Api/index.js';
import { Workers } from '../Workers/index.js';
export class Subscriptions {
    client;
    halted;
    events;
    instanceId;
    messageId;
    migrationDelay;
    migrationId;
    pingInterval;
    resolveHalted;
    subscriptions;
    ws;
    constructor(client, instanceId) {
        this.events = new EventEmitter();
        this.instanceId = instanceId;
        this.client = client;
        this.halted = Promise.resolve();
        this.messageId = 1;
        this.migrationId = 1;
        this.subscriptions = {};
    }
    async init() {
        if (typeof this.resolveHalted === 'undefined') {
            this.halted = new Promise(resolve => {
                this.resolveHalted = resolve;
            });
        }
        if (typeof this.client.accessToken === 'undefined') {
            this.client.logger.error(`[SUBSCRIPTIONS-${this.instanceId}] Can't initialise subscriptions without an access token. Ordering client to refresh tokens.`);
            await this.client.refreshTokens();
            await this.init();
            return;
        }
        this.ws = await this.createWebSocket(this.client.accessToken, this.migrationId);
        this.clearHalted();
    }
    async createWebSocket(accessToken, migrationId) {
        try {
            return await new Promise((resolve, reject) => {
                const that = this;
                function handleError(error) {
                    that.client.logger.error(`[SUBSCRIPTIONS-${that.instanceId}] An error occurred on the WebSocket.`, error.message);
                    if (this.readyState !== 1) {
                        this.removeAllListeners();
                        clearInterval(that.pingInterval);
                        reject(error);
                    }
                }
                function handlePing(data) {
                    that.client.logger.debug(`[SUBSCRIPTIONS-${that.instanceId}] Received WebSocket ping.`, data.toString());
                    this.pong(data);
                }
                function handlePong(data) {
                    that.client.logger.debug(`[SUBSCRIPTIONS-${that.instanceId}] Received WebSocket pong.`, data.toString());
                }
                async function handleClose(code, reason) {
                    that.client.logger.debug(`[SUBSCRIPTIONS-${that.instanceId}] WebSocket is closing with code ${code}: ${reason.toString()}`);
                    this.removeAllListeners();
                    clearInterval(that.pingInterval);
                    if (code !== 3000 && code !== 3001) {
                        that.client.logger.error(`[SUBSCRIPTIONS-${that.instanceId}] WebSocket closed abnormally with code ${code}: ${reason}`);
                        that.client.logger.info(`[SUBSCRIPTIONS-${that.instanceId}] Restarting WebSocket and subscriptions.`);
                        await that.recoverWebSocket();
                    }
                }
                function handleMessage(data, isBinary) {
                    if (isBinary) {
                        that.client.logger.error(`[SUBSCRIPTIONS-${that.instanceId}] Puking horses! ðŸ´ðŸ´ðŸ¤®`);
                        that.client.logger.debug(`[SUBSCRIPTIONS-${that.instanceId}] Received binary data on WebSocket.`, data.toString());
                        return;
                    }
                    const message = JSON.parse(data.toString());
                    if (typeof message.content === 'undefined') {
                        that.client.logger.error(`[SUBSCRIPTIONS-${that.instanceId}] Received a message with ID ${message.id} but no content.`, JSON.stringify(message));
                        return;
                    }
                    if (migrationId === that.migrationId &&
                        typeof that.resolveHalted !== 'undefined' &&
                        message.key === 'POST /ws/migrate') {
                        that.events.emit('migrate', message);
                        return;
                    }
                    that.client.logger.debug(`[SUBSCRIPTIONS-${that.instanceId}] Received ${message.event} message with ID ${message.id}.`, JSON.stringify(message));
                    const eventName = message.id === 0 ? `${message.event}/${message.key}` : `message-${message.id}`;
                    that.events.emit(eventName, {
                        ...message,
                        content: message.content.length > 0 ? JSON.parse(message.content) : message.content
                    });
                }
                function handleOpen() {
                    that.client.logger.debug(`[SUBSCRIPTIONS-${that.instanceId}] WebSocket opened.`);
                    this.on('ping', handlePing);
                    this.on('pong', handlePong);
                    this.on('message', handleMessage);
                    clearInterval(that.pingInterval);
                    that.pingInterval = setInterval(() => {
                        that.ping(this);
                    }, that.client.config.webSocketPingInterval);
                    resolve(ws);
                }
                this.client.logger.debug(`[SUBSCRIPTIONS-${that.instanceId}] Creating new WebSocket.`);
                const headers = {
                    'Content-Type': 'application/json',
                    'x-api-key': this.client.config.xApiKey,
                    'User-Agent': this.client.name,
                    'Authorization': `Bearer ${accessToken}`
                };
                this.client.logger.debug(`[SUBSCRIPTIONS-${that.instanceId}] Configured WebSocket headers.`, JSON.stringify(headers));
                const ws = new WebSocket(this.client.config.webSocketUrl, { headers });
                ws.on('error', handleError);
                ws.once('close', handleClose);
                ws.once('open', handleOpen);
                this.client.logger.debug(`[SUBSCRIPTIONS-${that.instanceId}] Created new WebSocket.`);
                clearTimeout(this.migrationDelay);
                this.migrationDelay = setTimeout(this.migrate.bind(this), this.client.config.webSocketMigrationInterval);
            });
        }
        catch (error) {
            this.client.logger.error(`[SUBSCRIPTIONS-${this.instanceId}] Something went wrong opening WebSocket to Alta. Retrying in ${this.client.config.webSocketRecoveryRetryDelay} ms. Error was: ${error.message}`);
            await new Promise(resolve => setTimeout(resolve, this.client.config.webSocketRecoveryRetryDelay));
            return await this.createWebSocket(accessToken, migrationId);
        }
    }
    ping(ws) {
        this.client.logger.debug(`[SUBSCRIPTIONS-${this.instanceId}] Pinging WebSocket.`);
        ws.ping(this.client.name);
    }
    async migrate(migrationToken) {
        await this.halted;
        if (typeof this.ws === 'undefined') {
            this.client.logger.warn(`[SUBSCRIPTIONS-${this.instanceId}] There is no WebSocket to migrate. Creating new WebSocket.`);
            await this.init();
            return;
        }
        if (typeof this.client.accessToken === 'undefined') {
            this.client.logger.warn(`[SUBSCRIPTIONS-${this.instanceId}] Can't migrate WebSocket without an access token. Ordering client to refresh tokens.`);
            await this.client.refreshTokens();
            await this.migrate();
            return;
        }
        this.client.logger.info(`[SUBSCRIPTIONS-${this.instanceId}] Beginning WebSocket migration.`);
        clearTimeout(this.migrationDelay);
        let token;
        if (typeof migrationToken === 'undefined') {
            this.client.logger.debug(`[SUBSCRIPTIONS-${this.instanceId}] Retrieving migration token.`);
            const requestMigrateResponse = await this.send('GET', 'migrate');
            if (typeof requestMigrateResponse === 'undefined') {
                await this.retryMigration();
                return;
            }
            token = requestMigrateResponse.content.token;
            this.client.logger.debug(`[SUBSCRIPTIONS-${this.instanceId}] Received migration token.`, token);
        }
        else {
            token = migrationToken;
            this.client.logger.debug(`[SUBSCRIPTIONS-${this.instanceId}] Reusing migration token.`, token);
        }
        this.halted = new Promise(resolve => {
            this.resolveHalted = resolve;
        });
        this.migrationId = this.getMigrationId();
        const oldWs = this.ws;
        delete this.ws;
        this.ws = await this.createWebSocket(this.client.accessToken, this.migrationId);
        try {
            await this.sendMigrationToken(token);
        }
        catch (error) {
            clearInterval(this.pingInterval);
            this.ws.removeAllListeners();
            this.ws.close(3001, 'Migration aborted.');
            delete this.ws;
            this.ws = oldWs;
            await this.recoverWebSocket();
            return;
        }
        this.clearHalted();
        this.client.logger.info(`[SUBSCRIPTIONS-${this.instanceId}] Successfully migrated WebSocket. Gracefully shutting down old WebSocket in ${this.client.config.webSocketMigrationHandoverPeriod} ms.`);
        await new Promise(resolve => setTimeout(resolve, this.client.config.webSocketMigrationHandoverPeriod));
        oldWs.close(3000, 'Migration completed.');
        oldWs.removeAllListeners();
        this.client.logger.info(`[SUBSCRIPTIONS-${this.instanceId}] Closed old WebSocket.`);
    }
    sendMigrationToken(token) {
        return new Promise((resolve, reject) => {
            this.events.once('migrate', message => {
                if (message.event === 'response' && message.responseCode === 200 && message.key === 'POST /ws/migrate') {
                    resolve(message.content);
                }
                else {
                    this.client.logger.error(`[SUBSCRIPTIONS-${this.instanceId}] Something went wrong posting the WebSocket migration token. Received message:`, JSON.stringify(message));
                    reject();
                }
            });
            this.send('POST', 'migrate', { token });
        });
    }
    async retryMigration(migrationToken) {
        this.client.logger.error(`[SUBSCRIPTIONS-${this.instanceId}] Client failed to migrate WebSocket. Retrying in ${this.client.config.webSocketMigrationRetryDelay} ms.`);
        await new Promise(resolve => setTimeout(resolve, this.client.config.webSocketMigrationRetryDelay));
        await this.migrate(migrationToken);
    }
    clearHalted() {
        if (typeof this.resolveHalted !== 'undefined') {
            this.client.logger.debug(`[SUBSCRIPTIONS-${this.instanceId}] Resolving halted Promise.`);
            this.resolveHalted();
            delete this.resolveHalted;
        }
    }
    async recoverWebSocket() {
        if (typeof this.client.accessToken === 'undefined') {
            this.client.logger.warn(`[SUBSCRIPTIONS-${this.instanceId}] Can't migrate WebSocket without an access token. Ordering client to refresh tokens.`);
            await this.client.refreshTokens();
            await this.recoverWebSocket();
            return;
        }
        this.client.logger.info(`[SUBSCRIPTIONS-${this.instanceId}] Recovering WebSocket connection.`);
        if (typeof this.resolveHalted === 'undefined') {
            this.halted = new Promise(resolve => {
                this.resolveHalted = resolve;
            });
        }
        clearInterval(this.pingInterval);
        this.migrationId = this.getMigrationId();
        this.ws?.removeAllListeners();
        delete this.ws;
        this.ws = await this.createWebSocket(this.client.accessToken, this.migrationId);
        this.clearHalted();
        const subscriptions = { ...this.subscriptions };
        this.subscriptions = {};
        const workers = new Workers(this.client.config.maxWorkerConcurrency);
        const tasks = Object.entries(subscriptions).map(([entry, callback]) => () => {
            const [subscription, key] = entry.split('/');
            if (typeof subscription !== 'string' || typeof key !== 'string')
                return Promise.resolve();
            this.events.removeAllListeners(entry);
            return (this.subscribe(subscription, key, callback) ??
                Promise.reject(new Error(`WebSocket recovery failed! Resubscribing to ${entry} was unsuccessful. Retrying recovery in ${this.client.config.webSocketRecoveryRetryDelay} ms.`)));
        });
        try {
            await Promise.race([
                await workers.do(tasks),
                new Promise((_, reject) => setTimeout(() => {
                    reject(new Error(`WebSocket recovery failed! Resubscribing was unsuccessful within ${this.client.config.webSocketRecoveryTimeout} ms. Retrying recovery in ${this.client.config.webSocketRecoveryRetryDelay} ms.`));
                }, this.client.config.webSocketRecoveryTimeout))
            ]);
        }
        catch (error) {
            this.halted = new Promise(resolve => {
                this.resolveHalted = resolve;
            });
            this.client.logger.error(`[SUBSCRIPTIONS-${this.instanceId}] ${error.message}`);
            await new Promise(resolve => setTimeout(resolve, this.client.config.webSocketRecoveryRetryDelay));
            this.subscriptions = subscriptions;
            await this.recoverWebSocket();
            return;
        }
        this.client.logger.info(`[SUBSCRIPTIONS-${this.instanceId}] Successfully recovered WebSocket connection.`);
    }
    getMessageId() {
        return this.messageId++;
    }
    getMigrationId() {
        return this.migrationId++;
    }
    async send(method, path, payload, attemptsLeft = this.client.config.webSocketRequestAttempts) {
        if (path !== 'migrate')
            await this.halted;
        return await new Promise((resolve, reject) => {
            if (typeof this.client.accessToken === 'undefined' || typeof this.ws === 'undefined') {
                this.client.logger.error(`[SUBSCRIPTIONS-${this.instanceId}] Cannot send WebSocket messages. Please verify that Client was initialised properly.`);
                reject(this.createErrorMessage("Can't send message on WebSocket."));
                return;
            }
            const id = this.getMessageId();
            this.events.once(`message-${id}`, (message) => {
                if (message.responseCode === 200) {
                    resolve(message);
                }
                else if (attemptsLeft > 0) {
                    this.client.logger.debug(`[SUBSCRIPTIONS-${this.instanceId}] Message-${id} has a non-200 responseCode. Retrying request in ${this.client.config.webSocketRequestRetryDelay} ms.`);
                    setTimeout(async () => {
                        try {
                            const result = await this.send(method, path, payload, attemptsLeft - 1);
                            resolve(result);
                        }
                        catch (error) {
                            reject(error);
                        }
                    }, this.client.config.webSocketRequestRetryDelay);
                }
                else {
                    this.client.logger.debug(`[SUBSCRIPTIONS-${this.instanceId}] Message-${id} has a non-200 responseCode. Exhausted maximum number of request attempts.`);
                    reject(message);
                }
            });
            const message = JSON.stringify({
                method,
                path,
                authorization: `Bearer ${this.client.accessToken}`,
                id,
                content: JSON.stringify(payload)
            });
            this.client.logger.debug(`[SUBSCRIPTIONS-${this.instanceId}] Sending message-${id}.`, JSON.stringify({ id, method, path, content: JSON.stringify(payload) }));
            this.ws.send(message, error => error && reject(this.createErrorMessage(error.message ?? 'Unknown error.')));
        }).catch((message) => {
            this.client.logger.error(`[SUBSCRIPTIONS-${this.instanceId}] Subscriptions.send() error:`, message.content.message);
        });
    }
    subscribe(event, key, callback) {
        const subscription = `${event}/${key}`;
        if (Object.keys(this.subscriptions).includes(subscription)) {
            this.client.logger.error(`[SUBSCRIPTIONS-${this.instanceId}] Already subscribed to ${subscription}.`);
            return;
        }
        this.client.logger.debug(`[SUBSCRIPTIONS-${this.instanceId}] Subscribing to ${subscription}.`);
        this.subscriptions = { ...this.subscriptions, [subscription]: callback };
        this.events.on(subscription, callback);
        return this.send('POST', `subscription/${subscription}`);
    }
    unsubscribe(event, key) {
        const subscription = `${event}/${key}`;
        if (!Object.keys(this.subscriptions).includes(subscription)) {
            this.client.logger.error(`[SUBSCRIPTIONS-${this.instanceId}] Subscription to ${subscription} does not exist.`);
            return;
        }
        this.client.logger.debug(`[SUBSCRIPTIONS-${this.instanceId}] Unsubscribing to ${subscription}.`);
        this.subscriptions = Object.fromEntries(Object.entries(this.subscriptions).filter(([key]) => key !== subscription));
        this.events.removeAllListeners(subscription);
        return this.send('DELETE', `subscription/${subscription}`);
    }
    createErrorMessage(reason, code) {
        return {
            id: 0,
            event: 'response',
            key: 'INTERNAL_ERROR',
            responseCode: 0,
            content: { message: reason, error_code: code?.toString() ?? 'None' }
        };
    }
    getSize() {
        return Object.keys(this.subscriptions).length;
    }
}
