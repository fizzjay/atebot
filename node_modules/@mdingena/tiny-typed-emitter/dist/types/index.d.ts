/// <reference types="node" resolution-mode="require"/>
import { EventEmitter } from 'node:events';
export type EventName = string | symbol;
export type ListenerSignature<L> = {
    [E in Extract<keyof L, EventName>]: (...args: any[]) => any;
};
export type DefaultListener = {
    [k: string]: (...args: any[]) => any;
};
export declare class TypedEmitter<L extends ListenerSignature<L> = DefaultListener> extends EventEmitter {
    static defaultMaxListeners: number;
    addListener<U extends Extract<keyof L, EventName>>(event: U, listener: L[U]): this;
    prependListener<U extends Extract<keyof L, EventName>>(event: U, listener: L[U]): this;
    prependOnceListener<U extends Extract<keyof L, EventName>>(event: U, listener: L[U]): this;
    removeListener<U extends Extract<keyof L, EventName>>(event: U, listener: L[U]): this;
    removeAllListeners(event?: Extract<keyof L, EventName>): this;
    once<U extends Extract<keyof L, EventName>>(event: U, listener: L[U]): this;
    on<U extends Extract<keyof L, EventName>>(event: U, listener: L[U]): this;
    off<U extends Extract<keyof L, EventName>>(event: U, listener: L[U]): this;
    emit<U extends Extract<keyof L, EventName>>(event: U, ...args: Parameters<L[U]>): boolean;
    eventNames<U extends Extract<keyof L, EventName>>(): U[];
    listenerCount(type: Extract<keyof L, EventName>): number;
    listeners<U extends Extract<keyof L, EventName>>(type: U): L[U][];
    rawListeners<U extends Extract<keyof L, EventName>>(type: U): L[U][];
    getMaxListeners(): number;
    setMaxListeners(n: number): this;
}
